// Объявление структуры дерева
// info - информационная часть
// *left, *right - указатели на следующие "ветки" дерева
// *root - инициализация переменной "корня" дерева

struct Tree {
	int info;
	Tree *left, *right;
} *root;

// Создание сбалансированного дерева
void balance(Tree **p, int n, int k, int *a) {
	if (n == k) {
		*p = NULL;
		return;
	} else {
		int m = (n + k) / 2;
		*p = new Tree;
		(*p)->info = a[m];
		balance(&(*p)->left, n, m, a);
		balance(&(*p)->right, m + 1, k, a);
	}
}

// Вызов балансировки, где &root - педерача адреса дерева, 0 и n - индекс первого и последнего элемента массива m
balance(&root, 0, n, m);
// На выходе имеем *root - сбалансированное дерево

// Но предварительно нам нужно отсортировать массив m, для того чтобы создать сбалансированное дерево
selectionSort(m, n);
// или
quickSort(m, 0, n - 1);
// Сортировку можно найти в пункте "Сортировка"

/*
Значит, алгоритм создания дерева выглядит так:
1) Заполняем массив значениями, затем сортируем его
2) Вызываем процедуру балансировки дерева, передаем туда корень, границы массива, сам массив, на выходе получаем сбалансированное дерево
*/